---
date: '2023-06-02'
title: '스프링부트 테스트 JUnit편'
categories: ['Others']
summary: '스프링부트 테스트 정복해보자구'
thumbnail: '../images/thumbnail/chocoball.webp'
---
## 테스트 코드의 필요성을 느꼈을 때
회사에서 개발을 하고 있다가 기존 기획과 달라지는 부분이 있어서 기능을 다시 새롭게 만들어야 하는 부분이 있었습니다. 이렇게 수정하면서 리팩토링도 같이 진행을 했었는데 변경된 수정 사항이 엣지 케이스에 동작을 하지 않고 오류가 발생하는 경우가 발생했습니다!  
앞으로는 이러한 일이 더 빈번하게 일어날텐데 어떻게 해야할까 고민하던 중에 예전에 리팩토링 책을 읽었을 때 리팩토링을 할 때는 언제나 테스트 코드가 존재해야한다고 들었던 것이 기억이 났습니다.


## 우리는 왜 테스트 코드를 작성하는가?
바로 이러한 장점들이 있기 때문!! 

1. **품질 확인**: 테스트 코드는 소프트웨어의 기능이 예상대로 작동하는지 확인하게 해줍니다. 이를 통해 개발자는 버그나 예상치 못한 동작을 빠르게 발견하고 수정할 수 있습니다.

2. **회귀 테스트**: 테스트 코드는 새로운 기능을 추가하거나 기존 코드를 변경했을 때 이전에 작동하던 기능이 여전히 잘 작동하는지 확인하는 데 도움이 됩니다. 이를 회귀 테스트라고 하며, 테스트 코드가 없다면 이러한 테스트를 수동으로 수행해야 할 수도 있습니다.

3. **리팩토링**: 코드베이스를 정리하거나 개선하는 작업을 리팩토링이라고 합니다. 테스트 코드는 개발자가 리팩토링하는 동안 기능이 여전히 올바르게 작동하는지 확인하는 데 도움이 됩니다.

4. **문서화**: 테스트 코드는 종종 코드의 사용법을 설명하는 데 사용됩니다. 개발자가 어떻게 API를 사용해야 하는지 또는 특정 기능이 어떻게 동작하는지 이해하려면 테스트 코드를 읽을 수 있습니다.

5. **신뢰성**: 테스트 코드는 사용자와 다른 개발자에게 소프트웨어의 신뢰성을 보여주는 좋은 방법입니다. 테스트 커버리지가 높을수록 코드의 신뢰성이 높다고 간주되며, 이는 개발자와 사용자 모두에게 중요한 특성입니다.

6. **개발 속도 증가**: 처음에는 테스트 코드를 작성하는 데 시간이 들 수 있지만, 장기적으로 보면 개발 과정을 가속화할 수 있습니다. 테스트 코드를 통해 빠르게 버그를 발견하고 수정할 수 있으며, 코드 변경의 영향을 쉽게 이해할 수 있습니다.

이러한 이유들로 인해 많은 개발자와 조직들이 테스트 코드 작성을 중요하게 여기며, 테스트 주도 개발(TDD)과 같은 방법론을 따르기도 합니다.

## 테스트를 작성할 때 꼭 TDD는 해야할까?
언제나 테스트 코드를 작성할 때면 테스트 주도 개발(TDD:Test Driven Development)가 따라오고는 합니다..! 과연 TDD는 꼭 해야하는 걸까요?  

테스트 주도 개발(TDD)는 소프트웨어 개발의 하나로, 테스트를 먼저 작성하고 그 테스트를 통과하는 코드를 작성하는 방법을 가르킵니다. 이는 테스트의 중요성을 강조하며, 테스트가 요구 사항의 정의와 동시에 품질을 보장하는 역할을 수행한다는 것을 나타냅니다.

그러나 <mark>TDD가 항상 적절한 것은 아닙니다. TDD의 적용 여부는 여러 요인에 따라 달라집니다!</mark>

1. **프로젝트의 복잡성**: 복잡한 프로젝트에서는 TDD가 매우 유용할 수 있습니다. 테스트를 먼저 작성함으로써 요구 사항을 명확히 이해하고, 코드의 구조와 설계를 개선하며, 향후 버그를 줄일 수 있습니다.

2. **프로젝트의 수명**: 장기 프로젝트에서는 TDD가 유용합니다. 코드 변경에 따른 회귀 테스트를 자동화하고, 리팩토링을 용이하게 하며, 코드베이스의 유지 보수를 돕습니다.

3. **팀의 경험**: TDD는 적절히 수행하려면 경험이 필요합니다. 팀원들이 TDD에 익숙하지 않다면, 이를 배우고 적용하는데 시간이 필요하며 이로 인해 초기 개발 속도가 느려질 수 있습니다.

4. **프로토타입 개발**: 빠르게 프로토타입을 만들어야 하는 경우에는 TDD가 항상 가장 좋은 방법이 아닐 수 있습니다. 이러한 경우에는 프로토타입이 만족스러운 결과를 보일 때까지 빠르게 반복하는 것이 중요하며, 이후에 안정된 버전을 개발하는 동안 TDD를 적용할 수 있습니다.

이처럼 TDD는 유용한 도구이지만, 항상 적용해야 하는 것은 아닙니다. 프로젝트의 특성과 요구 사항, 팀의 경험 등을 고려하여 TDD가 적절한지를 판단해야 합니다.

## 코틀린 스프링부트 라이브러리 
스프링 부트에서 Kotlin을 사용하여 테스트를 작성할 때 주로 사용하는 테스트 라이브러리는 **JUnit**, **Mockito**, 그리고 **Spring Boot Test**입니다. 이 라이브러리들을 사용하면 단위 테스트, 통합 테스트, 그리고 애플리케이션의 전체 라이프사이클을 테스트 할 수 있습니다.  
먼저 JUnit부터 간단히 알아봅시다!

### JUnit
Java 진영의 대표적인 Test Framework  
단위 테스트(Unit Test)를 위한 도구를 제공합니다.
- 단위 테스트란?   
  - 코드의 특정 모듈이 의도된대로 동작하는지 테스트하는 절차를 의미합니다.  
  - 모든 함수와 메소드에 대한 각각의 테스트 케이스를 작성하는 것입니다.
어노테이션을 기반으로 테스트를 지원합니다.  
단정문(Assert)으로 테스트 케이스의 기대값에 대해 수행 결과를 확인할 수 있습니다.  
JUnit5는 Spring Boot 2.2버전부터 사용합니다.  
JUnit5는 Jupiter, Platform, Vintage 모듈로 구성됩니다.

#### JUnit LifeCycle Annotation
JUnit5는 아래와 같은 테스트 라이프 사이클을 가지고 있습니다.
|Annotation|Description|
|---|---|
|@Test|테스트용 메소드를 표현하는 어노테이션|
|@BeforeEach|각 테스트 메소드가 시작되기 전에 실행되어야 하는 메소드를 표현|
|@AfterEach|각 테스트 메소드가 시작된 후 실행되어야 하는 메소드를 표현|
|@BeforeAll|테스트 시작 전에 실행되어야 하는 메소드를 표현 (static 처리 필요)|
|@AfterAll|테스트 종료 후에 실행되어야 하는 메소드를 표현 (static 처리 필요)|

#### 예시 코드
<div class="code-header">
	<span class="red btn"></span>
	<span class="yellow btn"></span>
	<span class="green btn"></span>
</div>


```kotlin
package com.example.Test

import org.junit.jupiter.api.*
import org.springframework.boot.test.context.SpringBootTest

class TestLifeCycle {
	@BeforeEach
	fun beforeEach() {
		println("## beforeEach 호출")
		println()
	}

	@AfterEach
	fun afterEach() {
		println("## afterEach 호출")
		println()
	}

	@Test
	fun test1() {
		println("## test1 시작")
		println()
	}

	@Test
	@DisplayName("Test 2")
	fun test2() {
		println("## test2 시작")
		println()
	}

	@Test
	@Disabled
	 // Disabled Annotation : 테스트를 실행하지 않게 설정하는 어노테이션
	fun test3() {
		println("## test3 시작")
		println()
	}

	companion object {
		@BeforeAll
		@JvmStatic
		fun beforeAll() {
			println("## BeforeAll호출 ")
			println()
		}

		@AfterAll
		@JvmStatic
		fun afterAll() {
			println("## afterAll 호출")
			println()
		}
	}
}
```
#### 출력 결과
```python
## BeforeAll호출 

## beforeEach 호출

## test1 시작

## afterEach 호출

## beforeEach 호출

## test2 시작

## afterEach 호출

## afterAll 호출
```
![테스트 실행 결과](../images/content/2023-05-29-17-51-45.png)
테스트 3는 Disable Annotation 때문에 실행이 되지 않았습니다!